## I/O 模型对比 ##

- 阻塞I/O ： 程序阻塞于读写函数。
- I/O 复用 ： 程序阻塞于 I/O 复用系统调用，但可同时监听多个 I/O 事件。对I/O 本身的读写操作是非阻塞的
- SIGIO 信号 ： 信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段。
- 异步I/O ： 内核执行读写操作并触发读写完成事件。程序没有阻塞阶段。

### Reactor 模式 ###

Reactor 是这样一种模式，它要求主线程（I/O 处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该时间通知给工作线程（逻辑单元），除此之外，主线程不做任何其他实质性的工作，读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

使用同步 I/O 模型 （以 epoll_wait 为例） 实现的 Reactor 模式的工作流程是 ：

1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件
2. 主线程 调用 epoll_wait 等待 socket 上有数据可读
3. 当 socket 上有数据可读时，epoll_wait 通知主线程，主线程则将 socket 可读事件放入请求队列。
4. 睡眠在请求队列上的某个 工作线程 被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册 该 socket 上的写就绪事件。
5. 主线程调用 epoll_wait 等待 socket 可写。
6. 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。
7. 睡眠在请求队列上的某个工作线程将被唤醒。它往 socket 上写入服务器处理客户请求的结果。


工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它 ： 对于可读事件，执行可读数据和处理请求的操作；对于可写事件，执行写数据的操作。因此，Reactor 模式中，没必要区分 “读工作线程” 和 “写工作线程”


###  Proactor 模式 ###

与 Reactor 模式不同，Proactor 模式将所有 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑，因此，Proactor 模式更符合 服务器编程框架。

使用 异步 I/O 模式 （以 aio_read 和 aio_write 为例） 实现的Proactor 模式的工作流程是 ： 


1. 冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详细参考  sigevent 的 man 手册）。
2. 主线程继续处理其他逻辑
3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。
5. 主线程继续处理其他逻辑
6. 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket 


连接 socket 上的读写事件是通过 aio_read/aio_write 向内核注册的，因此内核将通过信号来向应用程序报告连接 socket 上的读写事件。所以，主线程中 epoll_wait 调用仅能用来检测监听 socket 上的连接请求事件，而不能用来检测连接 socket 上的读写事件。


### 模拟 Proactor 模式 ###

使用 同步 I/O 原理模拟出 Proactor 模式的第一种方法。其原理是： 主线程执行数据读写操作，读写完成以后，主线程向工作线程通知这一 “完成事件”。 那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。

使用 同步 I/O 模型（epoll_wait 为例） 模拟出的 Proactor 模式的工作流程如下 ： 

1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件
2. 主线程调用 epoll_wait 等待 socket 上有数据可读
3. 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
4. 睡眠在请求队列上的某个工作线程被唤醒，他获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件
5. 主线程调用 epoll_wait 等待 socket 可写
6. 当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户端请求的结果。



### 半同步/半反应堆（half-sync/half-reactive）模式 ###

P 150

异步线程只有一个，由主线程来充当。 它负责监听所有 socket 上的事件。如果监听 socket 上有可读事件发生，即有心的连接请求到来，主线程就接受之以得到新的连接 socket, 然后往 epoll 内核事件表中注册该 socket 上的读写事件。如果连接 socket 上有读写事件发生，即有新的客户请求到来或有数据数据要发送至客户端，主线程就将连接 socket 插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。

**缺点：**

- 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费 CPU 时间。
- 每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将消耗大量 CPU 时间。



## 池 ##

既然服务器的硬件资源 “充裕”， 那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费” 服务器的硬件资源，以换取运行效率。这就是 **池** 的概念。池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，称为  **静态资源分配**


