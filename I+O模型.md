## I/O 模型对比 ##

- 阻塞I/O ： 程序阻塞于读写函数。
- I/O 复用 ： 程序阻塞于 I/O 复用系统调用，但可同时监听多个 I/O 事件。对I/O 本身的读写操作是非阻塞的
- SIGIO 信号 ： 信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段。
- 异步I/O ： 内核执行读写操作并触发读写完成事件。程序没有阻塞阶段。

### Reactor ###

Reactor 是这样一种模式，它要求主线程（I/O 处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该时间通知给工作线程（逻辑单元），除此之外，主线程不做任何其他实质性的工作，读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

使用同步 I/O 模型 （以 epoll_wait 为例） 实现的 Reactor 模式的工作流程是 ：

1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件
2. 主线程 调用 epoll_wait 等待 socket 上有数据可读
3. 当 socket 上有数据可读时，epoll_wait 通知主线程，主线程则将 socket 可读事件放入请求队列。
4. 睡眠在请求队列上的某个 工作线程 被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册 该 socket 上的写就绪事件。
5. 主线程调用 epoll_wait 等待 socket 可写。
6. 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。
7. 睡眠在请求队列上的某个工作线程将被唤醒。它往 socket 上写入服务器处理客户请求的结果。